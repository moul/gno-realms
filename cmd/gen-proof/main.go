package main

import (
	"encoding/hex"
	"flag"
	"fmt"
	"os"
	"strings"
	"text/template"

	ics23 "github.com/cosmos/ics23/go"

	dbm "github.com/cosmos/cosmos-db"

	channelv2types "github.com/cosmos/ibc-go/v10/modules/core/04-channel/v2/types"

	"cosmossdk.io/log"
	"cosmossdk.io/store/iavl"
	"cosmossdk.io/store/metrics"
	"cosmossdk.io/store/rootmulti"
	storetypes "cosmossdk.io/store/types"
)

func main() {
	exist := flag.Bool("exist", true, "produce an existence or non-existence proof")
	flag.Parse()

	if flag.NArg() != 3 {
		fmt.Println("Usage: gen-proof -exist=true MERKLE_PREFIX CLIENT_ID TYPE [APP_ACK]")
		os.Exit(1)
	}
	var (
		merklePrefix = flag.Arg(0)
		clientID     = flag.Arg(1)
		proofType    = flag.Arg(2)
		appAckStr    = flag.Arg(3)
		key          []byte
		value        []byte
	)
	appAck := []byte(appAckStr)
	// Try to decode appAck as hex
	bz, err := hex.DecodeString(appAckStr)
	if err == nil {
		appAck = bz
	}
	switch proofType {
	case "commitment":
		key = []byte(merklePrefix + clientID + "\x03\x00\x00\x00\x00\x00\x00\x00\x01")
		if *exist {
			value = channelv2types.CommitAcknowledgement(
				channelv2types.Acknowledgement{
					AppAcknowledgements: [][]byte{appAck},
				},
			)
		}
	default:
		fmt.Println("unhandled proof type", proofType)
		os.Exit(1)
	}

	fmt.Println(genProofCode(key, value))
}

func genProofCode(key, value []byte) string {
	db := dbm.NewMemDB()
	store := rootmulti.NewStore(db, log.NewNopLogger(), metrics.NewNoOpMetrics())
	iavlStoreKey := storetypes.NewKVStoreKey("iavlStoreKey")

	store.MountStoreWithDB(iavlStoreKey, storetypes.StoreTypeIAVL, nil)
	err := store.LoadVersion(0)
	if err != nil {
		panic(err)
	}
	iavlStore := store.GetCommitStore(iavlStoreKey).(*iavl.Store)
	// fill with fake data
	for _, ikey := range []byte{0x11, 0x32, 0x50, 0x72, 0x99} {
		key := []byte{ikey}
		iavlStore.Set(key, key)
	}
	if value != nil {
		// If value is not nil enter the key/value, otherwise that means we're
		// going to generate a non-existence proof.
		iavlStore.Set(key, value)
	}

	cid := store.Commit()

	// Get Proof
	res, err := store.Query(&storetypes.RequestQuery{
		Path:  "/iavlStoreKey/key",
		Data:  key,
		Prove: true,
	})
	if err != nil {
		panic(err)
	}

	// Decode ics23 proof
	proofs := make([]*ics23.CommitmentProof, len(res.ProofOps.Ops))
	// spew.Dump(reqres.Response.ProofOps.Ops)
	for i, op := range res.ProofOps.Ops {
		var p ics23.CommitmentProof
		err = p.Unmarshal(op.Data)
		if err != nil || p.Proof == nil {
			panic(fmt.Sprintf("could not unmarshal proof op into CommitmentProof at index %d: %v", i, err))
		}
		proofs[i] = &p
	}

	// Verify proof
	prt := rootmulti.DefaultProofRuntime()
	if value != nil {
		err = prt.VerifyValue(res.ProofOps, cid.Hash, "/iavlStoreKey/"+string(key), value)
	} else {
		err = prt.VerifyAbsence(res.ProofOps, cid.Hash, "/iavlStoreKey/"+string(key))
	}
	if err != nil {
		panic(err)
	}

	// Dump proof
	tmpl := `
{{define "existenceProof" -}}
&ics23.ExistenceProof{
      Key:   []byte("{{str .Key}}"),
      Value: []byte("{{str .Value}}"),
      Leaf: &ics23.LeafOp{
        Hash:         specs.LeafSpec.Hash,
        PrehashKey:   specs.LeafSpec.PrehashKey,
        PrehashValue: specs.LeafSpec.PrehashValue,
        Length:       specs.LeafSpec.Length,
        Prefix:       []byte("{{str .Leaf.Prefix}}"),
      },
      Path: []*ics23.InnerOp{
        {{range .Path -}}
        {
          Hash:   specs.InnerSpec.Hash,
          Prefix: []byte("{{str .Prefix}}"),
          Suffix: []byte("{{str .Suffix}}"),
        },
        {{end -}}
      },
    },
{{- end -}}
apphash, _ := hex.DecodeString("{{hex .Root}}")
specs := ics23.IavlSpec()
// NOTE proof generated by ./cmd/gen-proof {{if not (index .Proofs 0).GetExist}}-exist=false{{end}} {{.Args}}
proof := []ics23.CommitmentProof{

  // iavl proof
	{{- with index .Proofs 0}}
	{{- with .GetExist }}
  ics23.CommitmentProof_Exist{
    Exist: {{template "existenceProof" .}}
  },
	{{- end}}
	{{- with .GetNonexist}}
  ics23.CommitmentProof_Nonexist{
    Nonexist: &ics23.NonExistenceProof{
			Key: []byte("{{str .Key}}"),
			Left: {{template "existenceProof" .Left}}
			Right: {{template "existenceProof" .Right}}
		},
  },
	{{- end}}
	{{- end}}

  // rootmulti proof
	{{- with index .Proofs 1}}
  ics23.CommitmentProof_Exist{
    Exist: {{template "existenceProof" index .GetExist}}
  },
	{{- end}}

}
`
	t, err := template.New("").Funcs(template.FuncMap{
		"hex": func(bz []byte) string {
			return fmt.Sprintf("%x", bz)
		},
		"str": func(bz []byte) string {
			hex := fmt.Sprintf("%x", bz)
			var formatted string
			for i := 0; i < len(hex); i += 2 {
				formatted += "\\x" + hex[i:i+2]
			}
			return formatted
		},
	}).Parse(tmpl)
	if err != nil {
		panic(err)
	}
	var sb strings.Builder
	err = t.Execute(&sb, map[string]any{
		"Root":   cid.Hash,
		"Proofs": proofs,
		"Args":   "'" + strings.Join(flag.Args(), "' '") + "'",
	})
	if err != nil {
		panic(err)
	}
	return sb.String()
}
