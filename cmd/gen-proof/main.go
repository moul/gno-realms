package main

import (
	"encoding/hex"
	"encoding/json"
	"flag"
	"fmt"
	"os"
	"strings"
	"text/template"

	ics23 "github.com/cosmos/ics23/go"

	dbm "github.com/cosmos/cosmos-db"

	channelv2types "github.com/cosmos/ibc-go/v10/modules/core/04-channel/v2/types"

	"cosmossdk.io/log"
	"cosmossdk.io/store/iavl"
	"cosmossdk.io/store/metrics"
	"cosmossdk.io/store/rootmulti"
	storetypes "cosmossdk.io/store/types"
)

func main() {
	/*
		// helper to write the JSON packet
			bz, _ := json.Marshal(channelv2types.Packet{
				Sequence:          1,
				SourceClient:      "07-tendermint-42",
				DestinationClient: "07-tendermint-1",
				TimeoutTimestamp:  1234571490,
				Payloads: []channelv2types.Payload{{
					SourcePort:      "appID",
					DestinationPort: "appID",
					Encoding:        "application/json",
					Value:           []byte("{}"),
					Version:         "v1",
				}},
			})
			fmt.Println(string(bz))
			fmt.Println(os.Args[4])
			return
	*/

	flag.Parse()
	if flag.NArg() < 3 || flag.NArg() > 4 {
		fmt.Println("Usage: gen-proof MERKLE_PREFIX CLIENT_ID COMMITMENT_TYPE [COMMITMENT]")
		os.Exit(1)
	}
	var (
		merklePrefix   = flag.Arg(0)
		clientID       = flag.Arg(1)
		commitmentType = flag.Arg(2)
		commitment     = flag.Arg(3)
		key            []byte
		value          []byte
	)
	switch commitmentType {
	case "acknowledgement":
		// CONTRACT sequence=1
		key = []byte(merklePrefix + clientID + "\x03\x00\x00\x00\x00\x00\x00\x00\x01")
		if commitment != "" {
			// commitment holds the app acknowledgement. It can be arbitrary bytes
			// or hex bytes.
			appAck := []byte(commitment)
			bz, err := hex.DecodeString(commitment)
			if err == nil {
				appAck = bz
			}
			value = channelv2types.CommitAcknowledgement(
				channelv2types.Acknowledgement{
					AppAcknowledgements: [][]byte{appAck},
				},
			)
		}
	case "receipt":
		// CONTRACT sequence=1
		key = []byte(merklePrefix + clientID + "\x02\x00\x00\x00\x00\x00\x00\x00\x01")
		if commitment != "" {
			// receipt commitment value is always the byte 0x02
			value = []byte{0x02}
		}
	case "packet":
		// CONTRACT sequence=1
		key = []byte(merklePrefix + clientID + "\x01\x00\x00\x00\x00\x00\x00\x00\x01")
		// commitment holds the packet json serialized
		if commitment != "" {
			var packet channelv2types.Packet
			err := json.Unmarshal([]byte(commitment), &packet)
			if err != nil {
				panic(err)
			}
			value = channelv2types.CommitPacket(packet)
		}
	default:
		fmt.Println("unhandled proof type", commitmentType)
		os.Exit(1)
	}

	fmt.Println(genProofCode(key, value))
}

func genProofCode(key, value []byte) string {
	db := dbm.NewMemDB()
	store := rootmulti.NewStore(db, log.NewNopLogger(), metrics.NewNoOpMetrics())
	iavlStoreKey := storetypes.NewKVStoreKey("iavlStoreKey")

	store.MountStoreWithDB(iavlStoreKey, storetypes.StoreTypeIAVL, nil)
	err := store.LoadVersion(0)
	if err != nil {
		panic(err)
	}
	iavlStore := store.GetCommitStore(iavlStoreKey).(*iavl.Store)
	// fill with fake data
	for _, ikey := range []byte{0x11, 0x32, 0x50, 0x72, 0x99} {
		key := []byte{ikey}
		iavlStore.Set(key, key)
	}
	if value != nil {
		// If value is not nil enter the key/value, otherwise that means we're
		// going to generate a non-existence proof.
		iavlStore.Set(key, value)
	}

	cid := store.Commit()

	// Get Proof
	res, err := store.Query(&storetypes.RequestQuery{
		Path:  "/iavlStoreKey/key",
		Data:  key,
		Prove: true,
	})
	if err != nil {
		panic(err)
	}

	// Decode ics23 proof
	proofs := make([]*ics23.CommitmentProof, len(res.ProofOps.Ops))
	// spew.Dump(reqres.Response.ProofOps.Ops)
	for i, op := range res.ProofOps.Ops {
		var p ics23.CommitmentProof
		err = p.Unmarshal(op.Data)
		if err != nil || p.Proof == nil {
			panic(fmt.Sprintf("could not unmarshal proof op into CommitmentProof at index %d: %v", i, err))
		}
		proofs[i] = &p
	}

	// Verify proof
	prt := rootmulti.DefaultProofRuntime()
	if value != nil {
		err = prt.VerifyValue(res.ProofOps, cid.Hash, "/iavlStoreKey/"+string(key), value)
	} else {
		err = prt.VerifyAbsence(res.ProofOps, cid.Hash, "/iavlStoreKey/"+string(key))
	}
	if err != nil {
		panic(err)
	}

	// Dump proof
	tmpl := `
{{define "existenceProof" -}}
&ics23.ExistenceProof{
      Key:   {{bytes .Key}},
      Value: {{bytes .Value}},
      Leaf: &ics23.LeafOp{
        Hash:         specs.LeafSpec.Hash,
        PrehashKey:   specs.LeafSpec.PrehashKey,
        PrehashValue: specs.LeafSpec.PrehashValue,
        Length:       specs.LeafSpec.Length,
        Prefix:       {{bytes .Leaf.Prefix}},
      },
      Path: []*ics23.InnerOp{
        {{range .Path -}}
        {
          Hash:   specs.InnerSpec.Hash,
          Prefix: {{bytes .Prefix}},
          Suffix: {{bytes .Suffix}},
        },
        {{end -}}
      },
    },
{{- end -}}
apphash, _ := hex.DecodeString("{{hex .Root}}")
specs := ics23.IavlSpec()
// NOTE code generated by:
// go run -C ./cmd/gen-proof . {{.Args}}
proof := []ics23.CommitmentProof{

  // iavl proof
	{{- with index .Proofs 0}}
	{{- with .GetExist }}
  ics23.CommitmentProof_Exist{
    Exist: {{template "existenceProof" .}}
  },
	{{- end}}
	{{- with .GetNonexist}}
  ics23.CommitmentProof_Nonexist{
    Nonexist: &ics23.NonExistenceProof{
			Key: {{bytes .Key}},
			Left: {{template "existenceProof" .Left}}
			Right: {{template "existenceProof" .Right}}
		},
  },
	{{- end}}
	{{- end}}

  // rootmulti proof
	{{- with index .Proofs 1}}
  ics23.CommitmentProof_Exist{
    Exist: {{template "existenceProof" index .GetExist}}
  },
	{{- end}}

}
`
	t, err := template.New("").Funcs(template.FuncMap{
		"hex": func(bz []byte) string {
			return fmt.Sprintf("%x", bz)
		},
		"bytes": func(bz []byte) string {
			hex := fmt.Sprintf("%x", bz)
			var bytesStr string
			for i := 0; i < len(hex); i += 2 {
				bytesStr += "\\x" + hex[i:i+2]
			}
			return "[]byte(\"" + bytesStr + "\")"
		},
	}).Parse(tmpl)
	if err != nil {
		panic(err)
	}
	var sb strings.Builder
	err = t.Execute(&sb, map[string]any{
		"Root":   cid.Hash,
		"Proofs": proofs,
		"Args":   "'" + strings.Join(flag.Args(), "' '") + "'",
	})
	if err != nil {
		panic(err)
	}
	return sb.String()
}
