package main

import (
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestGenProofCode(t *testing.T) {
	tests := []struct {
		name        string
		key, value  []byte
		expectedRet string
	}{
		{
			name:  "existing key",
			key:   []byte("key"),
			value: []byte("value"),
			expectedRet: `
apphash, _ := hex.DecodeString("5b59d5adc57e7fc0583981c488888fb7bf933320ead3f84a074e75a1a7fa5de6")
specs := ics23.IavlSpec()
// NOTE code generated by:
// go run -C ./cmd/gen-proof . ''
proof := []ics23.CommitmentProof{

  // iavl proof
  ics23.CommitmentProof_Exist{
    Exist: &ics23.ExistenceProof{
      Key:   []byte("\x6b\x65\x79"),
      Value: []byte("\x76\x61\x6c\x75\x65"),
      Leaf: &ics23.LeafOp{
        Hash:         specs.LeafSpec.Hash,
        PrehashKey:   specs.LeafSpec.PrehashKey,
        PrehashValue: specs.LeafSpec.PrehashValue,
        Length:       specs.LeafSpec.Length,
        Prefix:       []byte("\x00\x02\x02"),
      },
      Path: []*ics23.InnerOp{
        {
          Hash:   specs.InnerSpec.Hash,
          Prefix: []byte("\x02\x04\x02\x20\x35\xf8\xea\x80\x53\x90\xe0\x84\x85\x4f\x39\x9b\x42\xcc\xde\xae\xa3\x3a\x1d\xed\xc1\x15\x63\x8a\xc4\x8d\x06\x00\x63\x7d\xba\x1f\x20"),
          Suffix: []byte(""),
        },
        {
          Hash:   specs.InnerSpec.Hash,
          Prefix: []byte("\x04\x08\x02\x20"),
          Suffix: []byte("\x20\x79\x8e\x2c\xaa\x96\xfd\xfb\xa3\x76\xdd\xeb\x47\x99\x99\x54\xd2\xf4\x7e\x65\x16\x22\x64\xb0\x53\x6a\xb5\xdf\xf7\xfc\x0a\x2e\x07"),
        },
        {
          Hash:   specs.InnerSpec.Hash,
          Prefix: []byte("\x06\x0c\x02\x20\x9a\xf3\x7d\xd5\x95\xa0\x19\x08\x03\xb5\xe0\x5a\xae\xf4\x2a\xe3\xfa\xd4\x99\xe4\xfb\xe3\x7f\x7c\xd3\x1c\xad\xff\x22\xa9\xee\x74\x20"),
          Suffix: []byte(""),
        },
        },
    },
  },

  // rootmulti proof
  ics23.CommitmentProof_Exist{
    Exist: &ics23.ExistenceProof{
      Key:   []byte("\x69\x61\x76\x6c\x53\x74\x6f\x72\x65\x4b\x65\x79"),
      Value: []byte("\xe5\x64\xc2\x80\x65\x64\x6a\x79\x57\x51\xa8\xcb\x6a\x80\x11\x65\x99\x3d\xdf\xbe\xa2\x91\xf0\x59\x12\xb1\xd7\x61\x12\x13\x69\x87"),
      Leaf: &ics23.LeafOp{
        Hash:         specs.LeafSpec.Hash,
        PrehashKey:   specs.LeafSpec.PrehashKey,
        PrehashValue: specs.LeafSpec.PrehashValue,
        Length:       specs.LeafSpec.Length,
        Prefix:       []byte("\x00"),
      },
      Path: []*ics23.InnerOp{
        },
    },
  },

}
`,
		},
		{
			name:  "non existing key",
			key:   []byte("key"),
			value: nil,
			expectedRet: `
apphash, _ := hex.DecodeString("82ea91f259352674360c621c4b0a1975cc076e3792b6d22a8bfbe8e7f7d0d2d7")
specs := ics23.IavlSpec()
// NOTE code generated by:
// go run -C ./cmd/gen-proof . ''
proof := []ics23.CommitmentProof{

  // iavl proof
  ics23.CommitmentProof_Nonexist{
    Nonexist: &ics23.NonExistenceProof{
			Key: []byte("\x6b\x65\x79"),
			Left: &ics23.ExistenceProof{
      Key:   []byte("\x50"),
      Value: []byte("\x50"),
      Leaf: &ics23.LeafOp{
        Hash:         specs.LeafSpec.Hash,
        PrehashKey:   specs.LeafSpec.PrehashKey,
        PrehashValue: specs.LeafSpec.PrehashValue,
        Length:       specs.LeafSpec.Length,
        Prefix:       []byte("\x00\x02\x02"),
      },
      Path: []*ics23.InnerOp{
        {
          Hash:   specs.InnerSpec.Hash,
          Prefix: []byte("\x04\x06\x02\x20"),
          Suffix: []byte("\x20\x79\x8e\x2c\xaa\x96\xfd\xfb\xa3\x76\xdd\xeb\x47\x99\x99\x54\xd2\xf4\x7e\x65\x16\x22\x64\xb0\x53\x6a\xb5\xdf\xf7\xfc\x0a\x2e\x07"),
        },
        {
          Hash:   specs.InnerSpec.Hash,
          Prefix: []byte("\x06\x0a\x02\x20\x9a\xf3\x7d\xd5\x95\xa0\x19\x08\x03\xb5\xe0\x5a\xae\xf4\x2a\xe3\xfa\xd4\x99\xe4\xfb\xe3\x7f\x7c\xd3\x1c\xad\xff\x22\xa9\xee\x74\x20"),
          Suffix: []byte(""),
        },
        },
    },
			Right: &ics23.ExistenceProof{
      Key:   []byte("\x72"),
      Value: []byte("\x72"),
      Leaf: &ics23.LeafOp{
        Hash:         specs.LeafSpec.Hash,
        PrehashKey:   specs.LeafSpec.PrehashKey,
        PrehashValue: specs.LeafSpec.PrehashValue,
        Length:       specs.LeafSpec.Length,
        Prefix:       []byte("\x00\x02\x02"),
      },
      Path: []*ics23.InnerOp{
        {
          Hash:   specs.InnerSpec.Hash,
          Prefix: []byte("\x02\x04\x02\x20"),
          Suffix: []byte("\x20\xa3\x03\x93\x0c\xa8\x83\x16\x18\xac\x7e\x4d\xdd\x10\x54\x6c\xfc\x36\x6f\xb7\x30\xd6\x63\x0c\x03\x0a\x97\x22\x6b\xbe\xfc\x69\x35"),
        },
        {
          Hash:   specs.InnerSpec.Hash,
          Prefix: []byte("\x04\x06\x02\x20\x35\xf8\xea\x80\x53\x90\xe0\x84\x85\x4f\x39\x9b\x42\xcc\xde\xae\xa3\x3a\x1d\xed\xc1\x15\x63\x8a\xc4\x8d\x06\x00\x63\x7d\xba\x1f\x20"),
          Suffix: []byte(""),
        },
        {
          Hash:   specs.InnerSpec.Hash,
          Prefix: []byte("\x06\x0a\x02\x20\x9a\xf3\x7d\xd5\x95\xa0\x19\x08\x03\xb5\xe0\x5a\xae\xf4\x2a\xe3\xfa\xd4\x99\xe4\xfb\xe3\x7f\x7c\xd3\x1c\xad\xff\x22\xa9\xee\x74\x20"),
          Suffix: []byte(""),
        },
        },
    },
		},
  },

  // rootmulti proof
  ics23.CommitmentProof_Exist{
    Exist: &ics23.ExistenceProof{
      Key:   []byte("\x69\x61\x76\x6c\x53\x74\x6f\x72\x65\x4b\x65\x79"),
      Value: []byte("\x38\x22\xf3\x2f\x21\x66\x53\x63\x29\x4f\x96\xed\xda\x15\xa7\x81\x1a\x67\x6c\x2b\xa9\xdd\xcc\xec\x46\x63\x64\xf1\x00\x69\x82\x7d"),
      Leaf: &ics23.LeafOp{
        Hash:         specs.LeafSpec.Hash,
        PrehashKey:   specs.LeafSpec.PrehashKey,
        PrehashValue: specs.LeafSpec.PrehashValue,
        Length:       specs.LeafSpec.Length,
        Prefix:       []byte("\x00"),
      },
      Path: []*ics23.InnerOp{
        },
    },
  },

}
`,
		},
	}
	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			ret := genProofCode(tt.key, tt.value)

			assert.Equal(t, tt.expectedRet, ret)
		})
	}
}
